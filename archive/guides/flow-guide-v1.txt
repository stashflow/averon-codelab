═══════════════════════════════════════════════════════════════════════════════
   AVERON CODELAB - COMPLETE SYSTEM FLOW GUIDE V1
═══════════════════════════════════════════════════════════════════════════════

╔═══════════════════════════════════════════════════════════════════════════╗
║                         USER HIERARCHY STRUCTURE                          ║
╚═══════════════════════════════════════════════════════════════════════════╝

Level 1: FULL ADMIN (You - Platform Owner)
├── Full control over the entire platform
├── Creates and manages Districts
├── Approves/Rejects class creation requests from District Admins
├── Assigns District Admins to Districts
├── Manages available courses (Python, JavaScript, Java, C++)
├── Views all analytics and activity logs
└── Access: /admin/panel

Level 2: DISTRICTS
├── Containers for schools/organizations
├── Each has a unique District Code
├── Configuration: max_classes, max_teachers, max_students
└── Managed by one or more District Admins

Level 3: DISTRICT ADMIN
├── Manages a specific district
├── Creates classes (must be approved by Full Admin)
├── Assigns teachers to classes
├── Views district-wide analytics
├── Cannot directly control student enrollment
└── Access: /district/[id]/dashboard

Level 4: TEACHER
├── Owns and manages assigned classes
├── Creates assignments for their courses
├── Controls assignment visibility (show/hide, scheduling)
├── Grades student submissions
├── Views class analytics and student progress
└── Access: /teacher/dashboard

Level 5: STUDENT
├── Lowest privilege level - the learners
├── Enrolls in classes via class codes
├── Views only visible assignments
├── Submits code solutions
├── Receives grades and feedback
└── Access: /student/dashboard

╔═══════════════════════════════════════════════════════════════════════════╗
║                     COMPLETE WORKFLOW SEQUENCES                           ║
╚═══════════════════════════════════════════════════════════════════════════╝

┌─────────────────────────────────────────────────────────────────────────┐
│ FLOW 1: DISTRICT ONBOARDING (Full Admin → District Admin)              │
└─────────────────────────────────────────────────────────────────────────┘

Step 1: Full Admin creates district
   ↓ Action: /admin/panel → "Create District"
   ↓ Input: District name, configuration (max_classes, max_teachers, max_students)
   ↓ Output: Unique District Code generated

Step 2: Full Admin assigns District Admin
   ↓ Action: Select user and assign "District Admin" role
   ↓ Link: User account → District
   ↓ Notification: Email sent to District Admin with credentials

Step 3: District Admin logs in
   ↓ Access: /district/[id]/dashboard
   ↓ Views: District configuration, available resources
   ↓ Next: Ready to create classes (requires approval)

┌─────────────────────────────────────────────────────────────────────────┐
│ FLOW 2: CLASS CREATION & APPROVAL WORKFLOW                             │
└─────────────────────────────────────────────────────────────────────────┘

Step 1: District Admin creates class request
   ↓ Action: District dashboard → "Request New Class"
   ↓ Input:
      • Class name (e.g., "AP Computer Science A - Period 3")
      • Grade level (9-12)
      • Subject/course type
      • Assign teacher to class
      • Select course(s) to be taught
   ↓ Submit: Request enters approval queue

Step 2: Full Admin reviews request
   ↓ Access: /admin/panel → "Pending Class Requests"
   ↓ Review:
      • District seat availability (within max_classes limit?)
      • Teacher assignment valid?
      • Course selection appropriate?
   ↓ Decision: Approve or Reject

Step 3a: If APPROVED
   ↓ Class becomes active in system
   ↓ Unique Class Code generated (e.g., "ACL-2024-XJ7K9")
   ↓ Teacher gains access to class dashboard
   ↓ Notification: Email to District Admin and Teacher
   ↓ Teacher can now share class code with students

Step 3b: If REJECTED
   ↓ Request marked as rejected with reason
   ↓ Notification: Email to District Admin with explanation
   ↓ District Admin can modify and resubmit

┌─────────────────────────────────────────────────────────────────────────┐
│ FLOW 3: STUDENT ENROLLMENT (Class Code → Class Access)                 │
└─────────────────────────────────────────────────────────────────────────┘

Step 1: Teacher shares class code
   ↓ Method: Email, LMS announcement, in-person, syllabus
   ↓ Code: "ACL-2024-XJ7K9"

Step 2: Student receives code and signs up
   ↓ Action: Student creates ACL account (or logs in)
   ↓ Navigate: /student/dashboard → "Join Class"
   ↓ Input: Enter class code "ACL-2024-XJ7K9"
   ↓ Submit: Class enrollment request created

Step 3: Teacher reviews enrollment request
   ↓ Access: Teacher dashboard → "Pending Requests" tab
   ↓ View: Student name, email, request timestamp
   ↓ Verify: Student is in correct class roster
   ↓ Decision: Approve or Deny

Step 4: Approval granted
   ↓ Student added to class roster
   ↓ Student auto-enrolled in class-assigned courses
   ↓ Notification: Email confirmation to student
   ↓ Student dashboard: Class appears in "My Classes"
   ↓ Access: Student can now view lessons and assignments

┌─────────────────────────────────────────────────────────────────────────┐
│ FLOW 4: COURSE NAVIGATION & LESSON COMPLETION                          │
└─────────────────────────────────────────────────────────────────────────┘

Step 1: Student accesses enrolled course
   ↓ Dashboard: Click on course tile (e.g., "Intro to Python")
   ↓ View: Course overview page with lesson list
   ↓ Structure: Lessons organized sequentially (Lesson 1, 2, 3...)

Step 2: Student opens lesson
   ↓ Click: "Lesson 3: For Loops and Iteration"
   ↓ Load: Lesson viewer interface
   ↓ Layout:
      • Left panel: Instructional content (text, examples)
      • Right panel: Code editor + Test runner

Step 3: Student reads lesson content
   ↓ Content includes:
      • Learning objectives
      • Conceptual explanation
      • Code examples with annotations
      • Practice problems (non-graded)

Step 4: Student writes code
   ↓ Code editor: Syntax highlighting, auto-indent
   ↓ Starter code: May include template or boilerplate
   ↓ Student writes solution to practice problem

Step 5: Student runs tests (CURRENT: Mock execution)
   ↓ Click: "Run Tests" button
   ↓ Mock runner: Simulates test execution
   ↓ Output:
      • Test 1: ✓ Passed
      • Test 2: ✓ Passed
      • Test 3: ✗ Failed - Expected [1,2,3], Got [1,2]
   ↓ Student debugs and reruns

Step 6: All tests pass → Lesson marked complete
   ↓ Database: `student_lesson_progress` updated
   ↓ Fields: completion_status = 'completed', completed_at = timestamp
   ↓ UI: Green checkmark appears on lesson
   ↓ Progress bar: Advances (e.g., "3/10 lessons completed")
   ↓ Next: Student proceeds to next lesson

┌─────────────────────────────────────────────────────────────────────────┐
│ FLOW 5: CHECKPOINT SUBMISSION & GRADING                                │
└─────────────────────────────────────────────────────────────────────────┘

Step 1: Student reaches checkpoint
   ↓ Checkpoint: Graded assessment within course (e.g., "Checkpoint 1: Functions")
   ↓ UI indicator: Different styling than regular lessons (e.g., star icon)

Step 2: Student views checkpoint problem
   ↓ Problem description: Detailed requirements, constraints
   ↓ Example input/output: Sample test cases shown
   ↓ Starter code: Provided template with function signature
   ↓ Point value: Shows how much checkpoint is worth (e.g., "10 points")

Step 3: Student writes solution
   ↓ Code editor: Student implements required functionality
   ↓ Local testing: Can run tests locally (mock execution)
   ↓ Iterative: Student debugs and refines solution

Step 4: Student submits checkpoint
   ↓ Click: "Submit for Grading" button
   ↓ Confirmation: "Are you sure? You have 2 submissions remaining"
   ↓ Database: Code stored in `checkpoint_submissions` table:
      • student_id, checkpoint_id, code, submitted_at
      • test_results (from mock runner)
      • status = 'submitted'

Step 5: Teacher grades submission (CURRENT: Manual grading)
   ↓ Access: Teacher dashboard → "Grading Queue"
   ↓ Filter: By class, assignment, or ungraded submissions
   ↓ View: Student code in viewer
   ↓ Review:
      • Does code meet requirements?
      • Code quality and style?
      • Test case results (from mock runner)
   ↓ Assign grade: Enter score (0-10 points)
   ↓ Feedback: Optional text feedback
   ↓ Submit: Grade recorded

Step 6: Student receives grade
   ↓ Notification: Email with grade and feedback
   ↓ Dashboard: Grade appears on checkpoint
   ↓ Gradebook: Checkpoint score updates overall course grade
   ↓ View: Student can view teacher feedback

┌─────────────────────────────────────────────────────────────────────────┐
│ FLOW 6: TEACHER ASSIGNMENT MANAGEMENT                                  │
└─────────────────────────────────────────────────────────────────────────┘

Step 1: Teacher creates assignment
   ↓ Access: Class dashboard → "Create Assignment"
   ↓ Select: Choose checkpoint or lesson to assign
   ↓ Configure:
      • Assignment name
      • Due date and time
      • Point value
      • Visibility: "Show now" or "Schedule for [date]"
      • Submission limits: Max attempts allowed
      • Late policy: Accept late / No late submissions
   ↓ Save: Assignment created

Step 2: Assignment becomes visible to students
   ↓ If "Show now": Immediately appears in student dashboard
   ↓ If scheduled: Appears on scheduled date/time
   ↓ Student view: Assignment card shows:
      • Assignment name
      • Due date (countdown timer)
      • Point value
      • Submission status (Not Started / In Progress / Submitted)

Step 3: Students work on assignment
   ↓ Click assignment → Opens associated lesson/checkpoint
   ↓ Student completes work and submits (see Flow 5)

Step 4: Teacher monitors progress
   ↓ Dashboard: Shows submission statistics
      • 15/25 students submitted
      • 8/25 students not started
      • 2/25 students in progress
   ↓ View: Individual student progress
   ↓ Reminders: Teacher can send reminder to non-submitters

Step 5: Teacher grades submissions (see Flow 5)

Step 6: Teacher manages assignment lifecycle
   ↓ Options:
      • Hide assignment (make invisible to students)
      • Extend due date
      • Reopen for resubmissions
      • Clone assignment for another class
      • Delete assignment (with confirmation)

┌─────────────────────────────────────────────────────────────────────────┐
│ FLOW 7: ANALYTICS & PROGRESS TRACKING (Current + Planned)             │
└─────────────────────────────────────────────────────────────────────────┘

CURRENT STATE:

Teacher Views Class Analytics:
   ↓ Dashboard: Class performance overview
   ↓ Metrics:
      • Class roster with enrollment status
      • Individual student progress (lessons completed, assignments submitted)
      • Grade distribution for each assignment
      • Time spent per student (from `student_lesson_progress`)
   ↓ Student detail view:
      • Timeline of lesson completions
      • Assignment grades
      • Code submission history

PLANNED ENHANCEMENTS:

Step 1: Nightly aggregation pipeline
   ↓ Scheduled job: Runs at 2:00 AM daily
   ↓ Processes:
      • Aggregate student activity from past 24 hours
      • Calculate concept-level mastery (e.g., loops, functions, conditionals)
      • Compute class averages and percentiles
      • Identify struggling students (< 60% on multiple checkpoints)
      • Detect inactive students (no login in 7+ days)
   ↓ Storage: Results stored in materialized views

Step 2: Teacher dashboard enhancements
   ↓ Class Overview:
      • Average grade by assignment
      • Completion rate trends over time
      • Engagement metrics (logins per week, time on platform)
   ↓ Concept Heatmap:
      • Visual grid showing which concepts class struggles with
      • Red = Many students failing, Green = Most students passing
      • Drill down to see which students need help
   ↓ Early Warning System:
      • List of at-risk students with recommendations
      • Suggested interventions (review lesson X, schedule 1-on-1)
   ↓ Comparison:
      • How this class compares to district/platform average

Step 3: District Admin analytics
   ↓ Cross-school dashboard:
      • Performance by school, grade level, course
      • Teacher effectiveness metrics (class averages, completion rates)
      • Curriculum effectiveness (which courses/lessons work best)
      • Resource utilization (seat usage, active vs. inactive accounts)
   ↓ Trends:
      • District-wide trends over time (semester, year-over-year)
      • Identify top-performing schools/teachers to learn from

Step 4: Student progress dashboard
   ↓ Personal Insights:
      • Progress timeline (lessons completed, grades over time)
      • Concept mastery radar chart (strengths and weaknesses)
      • Time spent vs. class average
      • Percentile rank in class (if enabled by teacher)
   ↓ Achievements:
      • Badges earned (e.g., "10 Lessons Completed", "Perfect Score")
      • Milestones reached (e.g., "Finished Python Basics")
      • Certificates available for download

┌─────────────────────────────────────────────────────────────────────────┐
│ FLOW 8: CODE EXECUTION PIPELINE (Planned - Priority #1)               │
└─────────────────────────────────────────────────────────────────────────┘

Step 1: Student writes code and clicks "Run Tests"
   ↓ Frontend: Code + test cases sent to API
   ↓ API: /api/execute
   ↓ Payload:
      {
        "language": "python",
        "source_code": "def add(a,b): return a+b",
        "test_cases": [
          {"input": "add(2,3)", "expected": "5"},
          {"input": "add(-1,1)", "expected": "0"}
        ]
      }

Step 2: API validates and enqueues job
   ↓ Validation:
      • User authenticated?
      • Rate limit check (max 10 runs per minute)
      • Code size check (max 10KB)
      • Language supported?
   ↓ Queue: Job added to Redis queue
   ↓ Job ID: Generated and returned to frontend
   ↓ Frontend: Shows "Running tests..." with spinner

Step 3: Worker picks up job from queue
   ↓ Worker pool: 10-50 workers running (scales based on load)
   ↓ Worker: Reads job from queue
   ↓ Spin up: Docker container or VM with language runtime
   ↓ Container config:
      • Image: python:3.11-alpine (minimal, secure base)
      • CPU: 1 core, 2 second timeout
      • Memory: 256MB limit
      • Network: Disabled (--network none)
      • Filesystem: Read-only except /tmp (max 10MB)

Step 4: Execute code in isolated sandbox
   ↓ Write: Student code to /tmp/solution.py
   ↓ Write: Test runner script to /tmp/test.py
   ↓ Execute: python /tmp/test.py
   ↓ For each test case:
      • Run student code with test input
      • Capture stdout, stderr
      • Compare output to expected
      • Record: pass/fail, execution time, memory used
   ↓ Timeout: If > 2 seconds, kill process (SIGKILL)
   ↓ Error handling: Catch syntax errors, runtime errors, exceptions

Step 5: Collect results and destroy container
   ↓ Results:
      {
        "test_results": [
          {"test": 1, "status": "passed", "time": "0.01s"},
          {"test": 2, "status": "passed", "time": "0.01s"}
        ],
        "overall": "2/2 passed",
        "errors": []
      }
   ↓ Container: Destroyed immediately (security)
   ↓ Cleanup: /tmp files deleted

Step 6: Return results to student
   ↓ Database: Store results in `checkpoint_submissions`
   ↓ API: Results sent to frontend via WebSocket or polling
   ↓ Frontend: Update UI with detailed results:
      • "✓ Test 1: Passed (0.01s)"
      • "✓ Test 2: Passed (0.01s)"
      • Show stdout/stderr if any
   ↓ If errors: Show error messages and stack traces
   ↓ Student: Can debug and rerun

SECURITY CONSIDERATIONS:
• No network access prevents data exfiltration
• Resource limits prevent denial-of-service
• Read-only filesystem prevents malware persistence
• Seccomp profiles whitelist only essential system calls
• Container destroyed after each run (no state leakage)
• Rate limiting prevents abuse

┌─────────────────────────────────────────────────────────────────────────┐
│ FLOW 9: PAYMENT & SUBSCRIPTION (Planned - Priority #2)                │
└─────────────────────────────────────────────────────────────────────────┘

TEACHER TRIAL TO PAID CONVERSION:

Step 1: Trial teacher receives upgrade prompts
   ↓ Trial limitations:
      • Max 5 students per class
      • Max 2 classes total
      • No access to advanced features (analytics, bulk grading)
      • 30-day trial period
   ↓ UI reminders: "7 days left in trial. Upgrade now!"

Step 2: Teacher clicks "Upgrade to Full Access"
   ↓ Redirect: Stripe Checkout page
   ↓ Plan selection:
      • Individual Teacher: $19/month or $180/year (save 20%)
      • Small School (up to 100 students): $49/month
      • Large School (up to 500 students): $199/month
      • Enterprise (district-wide): Contact sales
   ↓ Input: Payment method (credit card or ACH)

Step 3: Stripe processes payment
   ↓ Stripe: Creates customer and subscription
   ↓ Payment: Charged immediately
   ↓ Webhook: Stripe sends "payment_intent.succeeded" to ACL API
   ↓ ACL API: Receives webhook, validates signature

Step 4: Account upgraded to full access
   ↓ Database: Update user role to "teacher_full"
   ↓ Stripe: Save subscription_id and customer_id
   ↓ Limits: Remove trial restrictions
      • Unlimited students
      • Unlimited classes
      • Full feature access
   ↓ Notification: Email confirmation with receipt
   ↓ Dashboard: "Pro" badge appears on teacher profile

Step 5: Ongoing subscription management
   ↓ Auto-renewal: Stripe charges automatically each month/year
   ↓ Teacher can:
      • View subscription status in account settings
      • Update payment method
      • Upgrade/downgrade plan
      • Cancel subscription (retains access through end of billing period)
   ↓ Failed payment:
      • Email notification to update payment method
      • 7-day grace period before access revoked
      • Account downgraded to read-only mode (can export data)

DISTRICT SUBSCRIPTION:

Step 1: District Admin requests district subscription
   ↓ Form: Contact sales with district info
   ↓ Sales: ACL team provides custom quote
   ↓ Negotiation: Volume pricing, onboarding support, SLA

Step 2: Contract signed and invoice sent
   ↓ Agreement: Terms, seat count, annual billing
   ↓ Stripe: Invoice created and emailed
   ↓ Payment: District pays via ACH, wire, or credit card

Step 3: District provisioned
   ↓ Full Admin: Creates district in system
   ↓ Configuration:
      • max_classes: 100
      • max_teachers: 50
      • max_students: 2000
   ↓ District Admin: Account created and credentials sent
   ↓ SSO: Configure if requested

Step 4: District Admin manages allocation
   ↓ Dashboard: Shows seat utilization
      • 30/50 teacher seats used
      • 1,200/2,000 student seats used
   ↓ Allocate: Assign seats to schools within district
   ↓ Monitor: Usage and overage alerts

Step 5: Renewal automation
   ↓ 60 days before renewal: Email reminder to district
   ↓ 30 days before: Final reminder with renewal invoice
   ↓ Renewal date: Stripe auto-charges
   ↓ Success: Subscription continues, confirmation email
   ↓ Failure: Grace period, manual follow-up by sales team

┌─────────────────────────────────────────────────────────────────────────┐
│ FLOW 10: SSO & LMS INTEGRATION (Planned - Priority #3)                │
└─────────────────────────────────────────────────────────────────────────┘

GOOGLE WORKSPACE SSO:

Step 1: District Admin configures SSO (one-time setup)
   ↓ ACL Settings: Navigate to "Integrations" → "Single Sign-On"
   ↓ Select: "Google Workspace"
   ↓ Input: Google Workspace domain (e.g., "example.k12.us")
   ↓ OAuth: ACL redirects to Google OAuth consent screen
   ↓ District IT Admin: Grants permissions to ACL
   ↓ Mapping: Configure role mappings:
      • Google Group "Teachers" → ACL role "Teacher"
      • Google Group "Students" → ACL role "Student"
      • All others → Default role "Student"
   ↓ Save: SSO enabled for district

Step 2: Teacher/Student logs in via SSO
   ↓ ACL Login Page: Click "Sign in with Google"
   ↓ Redirect: Google login page
   ↓ User: Enters school Google credentials
   ↓ Google: Authenticates user
   ↓ OAuth: Google returns auth token to ACL
   ↓ Token contains: name, email, profile photo, group memberships

Step 3: ACL auto-provisions account (first login only)
   ↓ Check: Does user exist in ACL database?
   ↓ If NO (first time):
      • Create user account
      • Email: user@example.k12.us
      • Name: From Google profile
      • Role: Based on Google Group mapping (Teacher or Student)
      • District: Linked based on email domain
   ↓ If YES (returning user):
      • Update profile info if changed
      • Update role if group membership changed
   ↓ Session: Create authenticated session
   ↓ Redirect: User to appropriate dashboard (/teacher or /student)

Step 4: Ongoing SSO experience
   ↓ Single sign-on: User logs into Google once, automatically authenticated to ACL
   ↓ Single sign-out: Log out of Google → ACL session ends
   ↓ Account sync: Daily job syncs user info from Google
      • New users auto-provisioned
      • Deactivated users disabled in ACL
      • Role changes reflected

CANVAS LMS INTEGRATION (LTI 1.3):

Step 1: Teacher installs ACL LTI app in Canvas (one-time)
   ↓ Canvas Admin: Install ACL from Canvas App Store
   ↓ Or: Manual LTI configuration with ACL keys
   ↓ Grant: ACL permissions to:
      • Read course roster
      • Write grades to gradebook
      • Launch tool in assignment context
   ↓ Teacher: Add ACL to Canvas course
   ↓ Authorize: ACL can access this course

Step 2: Teacher creates assignment in Canvas
   ↓ Canvas: Create new assignment
   ↓ Assignment type: "External Tool"
   ↓ Select: "Averon CodeLab"
   ↓ Configure:
      • Choose ACL course and checkpoint
      • Set due date, point value in Canvas
   ↓ Publish: Assignment visible to students in Canvas

Step 3: Student launches assignment from Canvas
   ↓ Canvas: Student clicks on ACL assignment
   ↓ LTI Launch: Canvas sends signed LTI request to ACL:
      • User info (name, email, Canvas user ID)
      • Course info (Canvas course ID, assignment ID)
      • Roster info (student's role in course)
   ↓ ACL: Validates LTI signature
   ↓ ACL: Auto-provisions student account (if first time)
   ↓ ACL: Auto-enrolls student in ACL course
   ↓ ACL: Opens assignment in embedded iframe
   ↓ Student: Completes work in ACL (see Flow 5)
   ↓ No separate login: Seamless experience

Step 4: Student submits assignment in ACL
   ↓ Submit: Student clicks "Submit for Grading" in ACL
   ↓ ACL: Code graded (auto or manual)
   ↓ Grade: Calculated (e.g., 8/10 points = 80%)

Step 5: Grade synced back to Canvas
   ↓ LTI API: ACL sends grade to Canvas via LTI Advantage
   ↓ Payload:
      {
        "scoreGiven": 8,
        "scoreMaximum": 10,
        "comment": "Good work! Consider edge cases.",
        "timestamp": "2024-03-15T14:30:00Z"
      }
   ↓ Canvas: Grade appears in Canvas gradebook
   ↓ Timing: Within minutes (near real-time)
   ↓ Student: Sees grade in both ACL and Canvas
   ↓ Teacher: Sees grade in Canvas gradebook

Step 6: Roster sync (daily)
   ↓ Scheduled job: Runs daily at 3:00 AM
   ↓ LTI API: ACL fetches roster from Canvas
   ↓ Sync:
      • New students added to ACL class
      • Dropped students removed from ACL class
      • Role changes reflected (e.g., TA promoted to teacher)
   ↓ Notification: Teacher notified of roster changes

╔═══════════════════════════════════════════════════════════════════════════╗
║                         DATABASE SCHEMA OVERVIEW                          ║
╚═══════════════════════════════════════════════════════════════════════════╝

Key Tables and Relationships:

users
├── id (UUID, primary key)
├── email (unique)
├── role (full_admin, district_admin, teacher, student)
├── district_id (foreign key to districts)
└── trial_expires_at (for trial teachers)

districts
├── id (UUID, primary key)
├── name
├── district_code (unique, e.g., "DIST-XJ7K9")
├── max_classes, max_teachers, max_students
└── created_by (foreign key to users - the Full Admin who created it)

classes
├── id (UUID, primary key)
├── name
├── class_code (unique, e.g., "ACL-2024-XJ7K9")
├── district_id (foreign key to districts)
├── teacher_id (foreign key to users)
├── status (pending_approval, active, archived)
└── approved_by (foreign key to users - the Full Admin who approved)

class_enrollments
├── id (UUID, primary key)
├── class_id (foreign key to classes)
├── student_id (foreign key to users)
├── status (pending, approved, rejected)
└── enrolled_at

courses
├── id (UUID, primary key)
├── name (e.g., "Intro to Python")
├── language (python, javascript, java, cpp)
├── description
└── created_by (Full Admin)

course_enrollments
├── id (UUID, primary key)
├── course_id (foreign key to courses)
├── student_id (foreign key to users)
└── enrolled_at

lessons
├── id (UUID, primary key)
├── course_id (foreign key to courses)
├── sequence_number (1, 2, 3...)
├── title (e.g., "For Loops and Iteration")
├── content (JSON: instructional text, examples, etc.)
└── lesson_type (lesson, checkpoint)

student_lesson_progress
├── id (UUID, primary key)
├── student_id (foreign key to users)
├── lesson_id (foreign key to lessons)
├── status (not_started, in_progress, completed)
├── time_spent_seconds
├── started_at
└── completed_at

checkpoints
├── id (UUID, primary key)
├── lesson_id (foreign key to lessons)
├── problem_description (text)
├── starter_code (text)
├── test_cases (JSON array)
└── max_points

checkpoint_submissions
├── id (UUID, primary key)
├── checkpoint_id (foreign key to checkpoints)
├── student_id (foreign key to users)
├── code (text)
├── test_results (JSON)
├── grade (integer, 0-max_points)
├── teacher_feedback (text)
├── graded_by (foreign key to users)
├── submitted_at
└── graded_at

assignments
├── id (UUID, primary key)
├── class_id (foreign key to classes)
├── checkpoint_id (foreign key to checkpoints)
├── name
├── due_at
├── visible (boolean)
├── scheduled_visible_at
└── created_by (teacher_id)

╔═══════════════════════════════════════════════════════════════════════════╗
║                    ROW-LEVEL SECURITY (RLS) POLICIES                      ║
╚═══════════════════════════════════════════════════════════════════════════╝

CRITICAL SECURITY RULES:

Full Admin:
✓ Can SELECT, INSERT, UPDATE, DELETE on all tables
✓ No restrictions - platform owner

District Admin:
✓ Can SELECT districts WHERE district_id = their_district_id
✓ Can SELECT classes WHERE classes.district_id = their_district_id
✓ Can SELECT users WHERE users.district_id = their_district_id
✗ CANNOT modify districts table (only Full Admin can)
✓ Can INSERT into classes (creates request, pending approval)
✗ CANNOT set classes.status = 'active' (only Full Admin via approval)

Teacher:
✓ Can SELECT classes WHERE teacher_id = their_user_id
✓ Can SELECT class_enrollments WHERE class_id IN (their classes)
✓ Can SELECT checkpoint_submissions WHERE student_id IN (their class students)
✓ Can UPDATE checkpoint_submissions (grade, feedback) for their students
✗ CANNOT see other teachers' classes or students
✓ Can INSERT/UPDATE assignments for their classes

Student:
✓ Can SELECT courses they are enrolled in
✓ Can SELECT lessons for enrolled courses only
✓ Can SELECT their own student_lesson_progress
✓ Can INSERT/UPDATE their own student_lesson_progress
✓ Can INSERT into checkpoint_submissions (submit code)
✓ Can SELECT their own checkpoint_submissions
✗ CANNOT see other students' submissions
✗ CANNOT update grade or teacher_feedback fields
✓ Can INSERT into class_enrollments (create join request)
✗ CANNOT approve their own enrollment (only teacher can)

═══════════════════════════════════════════════════════════════════════════════
END OF COMPLETE FLOW GUIDE V1
═══════════════════════════════════════════════════════════════════════════════
